import Anthropic from "@anthropic-ai/sdk";
import { db } from "../db";
import { workouts, programs, screenings, workoutSets } from "@db/schema";
import { eq, and, desc, gte } from "drizzle-orm";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

interface AdaptFlowParams {
  userId: number;
  programId: number;
  triggerType:
    | "pain_detected"
    | "equipment_missing"
    | "fatigue_high"
    | "performance_decline"
    | "manual_request";
  triggerData: any;
}

interface AdaptFlowResult {
  warnings: string[];
  alternatives: Array<{
    from: string;
    to: string[];
    reason: string;
    priority: "high" | "medium" | "low";
  }>;
  generalAdvice: string;
  confidence: number;
}

export async function generateAdaptationSuggestions(
  params: AdaptFlowParams
): Promise<AdaptFlowResult> {
  try {
    // Gather comprehensive context
    const context = await gatherUserContext(params.userId, params.programId);

    // Build prompt based on trigger type
    const prompt = buildPrompt(params.triggerType, params.triggerData, context);

    // Call Claude
    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 2000,
      temperature: 0.3, // Lower temperature for more consistent suggestions
      messages: [
        {
          role: "user",
          content: prompt,
        },
      ],
    });

    const content = message.content[0];
    if (content.type !== "text") {
      throw new Error("Invalid response type from Claude");
    }

    // Parse JSON response
    const jsonMatch = content.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("No valid JSON found in response");
    }

    const result: AdaptFlowResult = JSON.parse(jsonMatch[0]);

    // Validate result
    if (!result.warnings || !result.alternatives) {
      throw new Error("Incomplete AI response");
    }

    return result;
  } catch (error) {
    console.error("AdaptFlow AI error:", error);
    return fallbackAdaptation(params);
  }
}

async function gatherUserContext(
  userId: number,
  programId: number
): Promise<any> {
  // Get user screening
  const [screening] = await db
    .select()
    .from(screenings)
    .where(eq(screenings.userId, userId))
    .orderBy(desc(screenings.createdAt))
    .limit(1);

  // Get program details
  const [program] = await db
    .select()
    .from(programs)
    .where(eq(programs.id, programId));

  // Get last 10 workouts
  const recentWorkouts = await db
    .select()
    .from(workouts)
    .where(eq(workouts.userId, userId))
    .orderBy(desc(workouts.createdAt))
    .limit(10);

  // Get workout sets with pain/issues
  const painfulSets = await db
    .select()
    .from(workoutSets)
    .where(
      and(
        eq(workoutSets.workoutId, recentWorkouts[0]?.id || 0)
        // Add more conditions as needed
      )
    );

  // Calculate workout stats
  const workoutStats = {
    totalCompleted: recentWorkouts.filter((w) => w.status === "completed")
      .length,
    averagePainLevel:
      recentWorkouts.reduce((sum, w) => sum + (w.painLevel || 0), 0) /
      recentWorkouts.length,
    averageEnergyLevel:
      recentWorkouts.reduce((sum, w) => sum + (w.energyLevel || 0), 0) /
      recentWorkouts.length,
    commonPainAreas: getMostCommonPainAreas(recentWorkouts),
  };

  return {
    screening,
    program,
    recentWorkouts: recentWorkouts.slice(0, 5), // Last 5 only for context
    workoutStats,
  };
}

function buildPrompt(
  triggerType: string,
  triggerData: any,
  context: any
): string {
  const baseContext = `
CONTESTO UTENTE:
- Goal: ${context.screening?.goal || "N/A"}
- Livello: ${context.screening?.level || "N/A"}
- Età: ${context.screening?.age || "N/A"}
- Localizzazione: ${context.screening?.location || "N/A"}
- Pain areas note: ${context.screening?.painAreas?.join(", ") || "Nessuna"}
- Equipment disponibile: ${JSON.stringify(context.screening?.equipment || {})}

PROGRAMMA ATTUALE:
- Nome: ${context.program?.name || "N/A"}
- Split: ${context.program?.split || "N/A"}
- Usa tecniche avanzate: Superset=${context.program?.usesSuperset}, Triset=${context.program?.usesTriset}

STATISTICHE RECENTI (ultimi ${context.recentWorkouts?.length || 0} workouts):
- Completati: ${context.workoutStats?.totalCompleted || 0}
- Pain level medio: ${context.workoutStats?.averagePainLevel?.toFixed(1) || "N/A"}/10
- Energy level medio: ${context.workoutStats?.averageEnergyLevel?.toFixed(1) || "N/A"}/10
- Zone dolore comuni: ${context.workoutStats?.commonPainAreas?.join(", ") || "Nessuna"}

ULTIMI WORKOUTS:
${context.recentWorkouts
  ?.map(
    (w: any) =>
      `- ${w.dayName} (${w.status}): Pain=${w.painLevel || "N/A"} @ ${w.painLocation || "N/A"}, Notes="${w.postWorkoutNotes || "N/A"}"`
  )
  .join("\n")}
`;

  let triggerContext = "";

  switch (triggerType) {
    case "pain_detected":
      triggerContext = `
TRIGGER: DOLORE RILEVATO
- Esercizio: ${triggerData.exerciseName}
- Livello dolore: ${triggerData.painLevel}/10
- Localizzazione: ${triggerData.painLocation}
- Occorrenze: ${triggerData.occurrences || 1}x negli ultimi workouts
- Note: ${triggerData.notes || "N/A"}
`;
      break;

    case "equipment_missing":
      triggerContext = `
TRIGGER: ATTREZZATURA MANCANTE
- Esercizio originale: ${triggerData.exerciseName}
- Equipment richiesto: ${triggerData.requiredEquipment}
- Location: ${triggerData.location}
`;
      break;

    case "fatigue_high":
      triggerContext = `
TRIGGER: AFFATICAMENTO ELEVATO
- Energy level: ${triggerData.energyLevel}/10
- Sleep: ${triggerData.sleepHours}h
- Workout consecutivi: ${triggerData.consecutiveWorkouts}
`;
      break;

    case "performance_decline":
      triggerContext = `
TRIGGER: CALO PERFORMANCE
- Esercizio: ${triggerData.exerciseName}
- Calo carico: ${triggerData.weightDecline}%
- Calo reps: ${triggerData.repsDecline}
- Periodo: ultimi ${triggerData.periodWeeks} settimane
`;
      break;

    case "manual_request":
      triggerContext = `
TRIGGER: RICHIESTA MANUALE
- Motivo: ${triggerData.reason || "Utente ha richiesto suggerimenti"}
- Note specifiche: ${triggerData.notes || "N/A"}
`;
      break;
  }

  return `${baseContext}

${triggerContext}

Sei un AI assistant esperto di TrainSmart, specializzato in adattamento programmi di allenamento.

COMPITO:
Analizza la situazione e fornisci suggerimenti intelligenti per adattare il programma.

RISPONDI IN FORMATO JSON (solo JSON valido):
{
  "warnings": [
    "<warning critico 1 se presente>",
    "<warning critico 2 se presente>"
  ],
  "alternatives": [
    {
      "from": "<esercizio problematico>",
      "to": ["<alternativa 1>", "<alternativa 2>", "<alternativa 3>"],
      "reason": "<spiegazione breve e chiara del perché>",
      "priority": "<high/medium/low>"
    }
  ],
  "generalAdvice": "<consiglio generale per la situazione (max 150 caratteri)>",
  "confidence": <0.7-0.95>
}

LINEE GUIDA:
1. WARNINGS: Solo se ci sono situazioni critiche (es. dolore persistente, rischio infortunio)
2. ALTERNATIVES: Fornisci 2-3 esercizi alternativi che rispettano equipment e location
3. Le alternative devono lavorare gli stessi muscoli target
4. Priority: high = rischio infortunio, medium = efficacia ridotta, low = ottimizzazione
5. Sii SPECIFICO e PRATICO
6. Se non ci sono problemi gravi, warnings può essere array vuoto
7. Confidence alto (0.85-0.95) se hai dati sufficienti, più basso (0.7-0.8) se info limitate

ESEMPI DI BUONE ALTERNATIVES:
✅ from: "Barbell Squat", to: ["Goblet Squat", "Bulgarian Split Squat", "Leg Press"]
✅ reason: "Minore stress lombare mantenendo stimolo quadricipiti"

ESEMPI DI CATTIVE ALTERNATIVES:
❌ from: "Bench Press", to: ["Jogging"] (muscoli diversi)
❌ reason: "È meglio" (non specifico)
`;
}

function getMostCommonPainAreas(workouts: any[]): string[] {
  const painMap = new Map<string, number>();

  workouts.forEach((w) => {
    if (w.painLocation && w.painLevel && w.painLevel > 3) {
      const count = painMap.get(w.painLocation) || 0;
      painMap.set(w.painLocation, count + 1);
    }
  });

  return Array.from(painMap.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map((entry) => entry[0]);
}

function fallbackAdaptation(params: AdaptFlowParams): AdaptFlowResult {
  // Basic rule-based fallback
  const alternatives: AdaptFlowResult["alternatives"] = [];

  if (params.triggerType === "pain_detected") {
    alternatives.push({
      from: params.triggerData.exerciseName,
      to: ["Esercizio alternativo a basso impatto"],
      reason: "Riduzione stress sulla zona dolente",
      priority: "high",
    });
  }

  return {
    warnings:
      params.triggerType === "pain_detected"
        ? ["Dolore persistente rilevato - considera riposo"]
        : [],
    alternatives,
    generalAdvice: "Consulta un professionista se i problemi persistono",
    confidence: 0.6,
  };
}

// Helper function to check if adaptation is needed
export async function checkIfAdaptationNeeded(
  userId: number,
  programId: number
): Promise<{ needed: boolean; triggerType?: string; triggerData?: any }> {
  // Get recent workouts
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

  const recentWorkouts = await db
    .select()
    .from(workouts)
    .where(
      and(
        eq(workouts.userId, userId),
        eq(workouts.programId, programId),
        gte(workouts.createdAt, thirtyDaysAgo)
      )
    )
    .orderBy(desc(workouts.createdAt));

  // Check for persistent pain
  const painfulWorkouts = recentWorkouts.filter(
    (w) => w.painLevel && w.painLevel >= 5
  );

  if (painfulWorkouts.length >= 3) {
    // Same area pain 3+ times
    const painAreas = painfulWorkouts
      .map((w) => w.painLocation)
      .filter(Boolean);
    const mostCommon = getMostFrequent(painAreas);

    if (mostCommon) {
      return {
        needed: true,
        triggerType: "pain_detected",
        triggerData: {
          painLocation: mostCommon,
          occurrences: painfulWorkouts.length,
          averagePainLevel:
            painfulWorkouts.reduce((sum, w) => sum + (w.painLevel || 0), 0) /
            painfulWorkouts.length,
        },
      };
    }
  }

  // Check for low energy consistently
  const lowEnergyWorkouts = recentWorkouts.filter(
    (w) => w.energyLevel && w.energyLevel <= 3
  );

  if (lowEnergyWorkouts.length >= 4) {
    return {
      needed: true,
      triggerType: "fatigue_high",
      triggerData: {
        occurrences: lowEnergyWorkouts.length,
        averageEnergy:
          lowEnergyWorkouts.reduce((sum, w) => sum + (w.energyLevel || 0), 0) /
          lowEnergyWorkouts.length,
      },
    };
  }

  return { needed: false };
}

function getMostFrequent(arr: (string | null)[]): string | null {
  if (arr.length === 0) return null;

  const frequency = new Map<string, number>();
  let maxFreq = 0;
  let mostFrequent: string | null = null;

  arr.forEach((item) => {
    if (item) {
      const count = (frequency.get(item) || 0) + 1;
      frequency.set(item, count);

      if (count > maxFreq) {
        maxFreq = count;
        mostFrequent = item;
      }
    }
  });

  return mostFrequent;
}