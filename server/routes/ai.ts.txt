import { Router } from "express";
import { db } from "../db";
import {
  bodyCompositionAssessments,
  formCorrections,
  aiAdaptationSuggestions,
  users,
} from "@db/schema";
import { eq, desc } from "drizzle-orm";
import multer from "multer";
import {
  analyzeBodyComposition,
  calculateBMI,
  getBMICategory,
} from "../services/bodyCompositionAI";
import {
  analyzeExerciseForm,
  validateVideoDuration,
  getExerciseTips,
} from "../services/formCorrectionAI";
import {
  generateAdaptationSuggestions,
  checkIfAdaptationNeeded,
} from "../services/adaptFlowAI";
import { aiLimitMiddleware, checkAILimit, getAIUsageStats } from "../middleware/aiLimits";

const router = Router();

const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max per file
  },
  fileFilter: (req, file, cb) => {
    // Validate file types
    if (file.fieldname.startsWith("photo")) {
      if (!file.mimetype.startsWith("image/")) {
        return cb(new Error("Solo immagini permesse per le foto"));
      }
    } else if (file.fieldname === "video") {
      if (!file.mimetype.includes("video")) {
        return cb(new Error("Solo video permessi"));
      }
    }
    cb(null, true);
  },
});

// ===== 1. BODY COMPOSITION ANALYSIS =====

router.post(
  "/body-composition/analyze",
  aiLimitMiddleware("bodyComposition"),
  upload.fields([
    { name: "photoFront", maxCount: 1 },
    { name: "photoBack", maxCount: 1 },
    { name: "photoSide", maxCount: 1 },
  ]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { weight, height, waistCm, chestCm, armCm, thighCm } = req.body;

      // Validate required fields
      if (!weight || !height) {
        return res.status(400).json({ error: "Weight and height required" });
      }

      const weightNum = parseFloat(weight);
      const heightNum = parseFloat(height);

      if (
        isNaN(weightNum) ||
        isNaN(heightNum) ||
        weightNum < 30 ||
        weightNum > 300 ||
        heightNum < 100 ||
        heightNum > 250
      ) {
        return res.status(400).json({ error: "Invalid weight or height values" });
      }

      const files = req.files as any;
      const photos: { front?: Buffer; back?: Buffer; side?: Buffer } = {};

      if (files) {
        if (files.photoFront?.[0]) photos.front = files.photoFront[0].buffer;
        if (files.photoBack?.[0]) photos.back = files.photoBack[0].buffer;
        if (files.photoSide?.[0]) photos.side = files.photoSide[0].buffer;
      }

      // Calculate BMI
      const bmi = await calculateBMI(weightNum, heightNum);
      const bmiCategory = getBMICategory(bmi);

      // Run AI analysis if photos provided
      let aiAnalysis = null;
      if (Object.keys(photos).length > 0) {
        aiAnalysis = await analyzeBodyComposition({
          photos,
          weight: weightNum,
          height: heightNum,
        });
      }

      // Save to database
      const [assessment] = await db
        .insert(bodyCompositionAssessments)
        .values({
          userId,
          weight: weightNum,
          height: heightNum,
          bmi,
          photoFrontUrl: files?.photoFront ? "uploaded" : null,
          photoBackUrl: files?.photoBack ? "uploaded" : null,
          photoSideUrl: files?.photoSide ? "uploaded" : null,
          aiAnalysis,
          aiModelUsed: aiAnalysis ? "gemini-1.5-pro" : null,
          waistCm: waistCm ? parseFloat(waistCm) : null,
          chestCm: chestCm ? parseFloat(chestCm) : null,
          armCm: armCm ? parseFloat(armCm) : null,
          thighCm: thighCm ? parseFloat(thighCm) : null,
        })
        .returning();

      // Update user stats
      await db
        .update(users)
        .set({
          aiPhotoAnalysisUsed: db.$count(users.aiPhotoAnalysisUsed) + 1,
          lastAiPhotoDate: new Date(),
        })
        .where(eq(users.id, userId));

      res.json({
        success: true,
        assessmentId: assessment.id,
        bmi,
        bmiCategory,
        ...aiAnalysis,
      });
    } catch (error: any) {
      console.error("Body composition error:", error);
      res.status(500).json({ error: error.message || "Analysis failed" });
    }
  }
);

// Get user's body composition history
router.get("/body-composition/history", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const history = await db
      .select()
      .from(bodyCompositionAssessments)
      .where(eq(bodyCompositionAssessments.userId, userId))
      .orderBy(desc(bodyCompositionAssessments.createdAt))
      .limit(10);

    res.json(history);
  } catch (error: any) {
    console.error("History error:", error);
    res.status(500).json({ error: error.message });
  }
});

// ===== 2. FORM CORRECTION ANALYSIS =====

router.post(
  "/form-correction/analyze",
  aiLimitMiddleware("formCorrection"),
  upload.single("video"),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { workoutId, exerciseName } = req.body;
      const videoFile = req.file;

      if (!videoFile) {
        return res.status(400).json({ error: "No video provided" });
      }

      if (!exerciseName) {
        return res.status(400).json({ error: "Exercise name required" });
      }

      // Validate video duration/size
      if (!validateVideoDuration(videoFile.buffer)) {
        return res.status(400).json({
          error: "Video troppo lungo o pesante. Max 10 secondi.",
        });
      }

      // Run AI analysis
      const aiCorrections = await analyzeExerciseForm({
        videoBuffer: videoFile.buffer,
        exerciseName,
      });

      // Save to database
      const [correction] = await db
        .insert(formCorrections)
        .values({
          userId,
          workoutId: workoutId ? parseInt(workoutId) : null,
          exerciseName,
          videoUrl: "temp-storage", // TODO: Upload to cloud storage
          videoDuration: Math.round(videoFile.size / 100000), // Rough estimate
          aiCorrections,
          status: "analyzed",
        })
        .returning();

      // Update user stats
      await db
        .update(users)
        .set({
          aiVideoCorrectionsUsed: db.$count(users.aiVideoCorrectionsUsed) + 1,
          lastAiVideoDate: new Date(),
        })
        .where(eq(users.id, userId));

      res.json({
        success: true,
        correctionId: correction.id,
        ...aiCorrections,
      });
    } catch (error: any) {
      console.error("Form correction error:", error);
      res.status(500).json({ error: error.message || "Analysis failed" });
    }
  }
);

// Get exercise tips (free, no limit)
router.get("/form-correction/tips/:exerciseName", async (req, res) => {
  try {
    const { exerciseName } = req.params;
    const tips = getExerciseTips(exerciseName);

    res.json({ exerciseName, tips });
  } catch (error: any) {
    console.error("Tips error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get user's correction history
router.get("/form-correction/history", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const history = await db
      .select()
      .from(formCorrections)
      .where(eq(formCorrections.userId, userId))
      .orderBy(desc(formCorrections.createdAt))
      .limit(20);

    res.json(history);
  } catch (error: any) {
    console.error("History error:", error);
    res.status(500).json({ error: error.message });
  }
});

// ===== 3. ADAPTFLOW AI SUGGESTIONS =====

router.post("/adaptflow/suggestions", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const { programId, triggerType, triggerData } = req.body;

    if (!programId || !triggerType) {
      return res.status(400).json({ error: "programId and triggerType required" });
    }

    // Generate AI suggestions
    const suggestions = await generateAdaptationSuggestions({
      userId,
      programId: parseInt(programId),
      triggerType,
      triggerData: triggerData || {},
    });

    // Save to database
    const [suggestion] = await db
      .insert(aiAdaptationSuggestions)
      .values({
        userId,
        programId: parseInt(programId),
        triggerType,
        triggerData: triggerData || {},
        suggestions,
      })
      .returning();

    res.json({
      success: true,
      suggestionId: suggestion.id,
      ...suggestions,
    });
  } catch (error: any) {
    console.error("AdaptFlow AI error:", error);
    res.status(500).json({ error: error.message || "Generation failed" });
  }
});

// Check if adaptation is needed (automatic check)
router.get("/adaptflow/check/:programId", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const { programId } = req.params;

    const check = await checkIfAdaptationNeeded(userId, parseInt(programId));

    res.json(check);
  } catch (error: any) {
    console.error("Adaptation check error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Update suggestion action (accepted/dismissed)
router.patch("/adaptflow/suggestions/:id/action", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const { id } = req.params;
    const { action } = req.body; // "accepted" | "dismissed"

    if (!["accepted", "dismissed"].includes(action)) {
      return res.status(400).json({ error: "Invalid action" });
    }

    const [updated] = await db
      .update(aiAdaptationSuggestions)
      .set({
        userAction: action,
        appliedAt: action === "accepted" ? new Date() : null,
      })
      .where(eq(aiAdaptationSuggestions.id, parseInt(id)))
      .returning();

    res.json(updated);
  } catch (error: any) {
    console.error("Update action error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Get user's suggestion history
router.get("/adaptflow/history", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const history = await db
      .select()
      .from(aiAdaptationSuggestions)
      .where(eq(aiAdaptationSuggestions.userId, userId))
      .orderBy(desc(aiAdaptationSuggestions.createdAt))
      .limit(20);

    res.json(history);
  } catch (error: any) {
    console.error("History error:", error);
    res.status(500).json({ error: error.message });
  }
});

// ===== 4. AI USAGE STATS & LIMITS =====

router.get("/usage-stats", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const stats = await getAIUsageStats(userId);
    res.json(stats);
  } catch (error: any) {
    console.error("Usage stats error:", error);
    res.status(500).json({ error: error.message });
  }
});

// Check specific limit
router.get("/check-limit/:featureType", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ error: "Unauthorized" });

    const { featureType } = req.params;

    if (
      !["bodyComposition", "formCorrection", "adaptFlowSuggestions"].includes(
        featureType
      )
    ) {
      return res.status(400).json({ error: "Invalid feature type" });
    }

    const limitCheck = await checkAILimit(
      userId,
      featureType as "bodyComposition" | "formCorrection" | "adaptFlowSuggestions"
    );

    res.json(limitCheck);
  } catch (error: any) {
    console.error("Check limit error:", error);
    res.status(500).json({ error: error.message });
  }
});

export default router;